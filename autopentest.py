#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import argparse
import logging
from rich.console import Console
from rich.logging import RichHandler
from datetime import datetime
from modules.info_gathering import InfoGathering
from modules.port_scanner import PortScanner
from modules.vuln_scanner import VulnScanner
from modules.exploit_manager import ExploitManager
from modules.post_exploit import PostExploit
from modules.ai_analyzer import AIAnalyzer
from modules.report_generator import ReportGenerator
from modules.waf_bypass import WAFBypass

# 检查root权限
if os.geteuid() != 0:
    print("[-] 错误：必须使用sudo权限运行！")
    sys.exit(1)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    datefmt="[%X]",
    handlers=[
        RichHandler(rich_tracebacks=True),
        logging.FileHandler("/var/log/autopentest.log")
    ]
)

logger = logging.getLogger("autopentest")
console = Console()

class AutoPentest:
    def __init__(self, target, level=1, output=None, quiet=False, bypass_waf=False):
        self.target = target
        self.level = level
        self.output_dir = output or f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.quiet = quiet
        self.bypass_waf = bypass_waf
        self.results = {}
        
        # 创建输出目录
        os.makedirs(self.output_dir, exist_ok=True)
    
    def start(self):
        """启动渗透测试流程"""
        try:
            console.print("[bold green]开始自动化渗透测试...[/bold green]")
            
            # 1. WAF检测和绕过
            if self.bypass_waf:
                self._waf_bypass()
            
            # 2. 信息收集
            self._info_gathering()
            
            # 3. 端口扫描
            self._port_scan()
            
            # 4. 漏洞扫描
            self._vulnerability_scan()
            
            # 5. 漏洞利用
            if self.level >= 3:
                self._exploit()
            
            # 6. 后渗透
            if self.level >= 4:
                self._post_exploit()
            
            # 7. AI分析
            if self.level >= 2:
                self._ai_analysis()
            
            # 8. 生成报告
            self._generate_report()
            
        except Exception as e:
            logger.error(f"测试过程中发生错误: {str(e)}")
            raise
    
    def _waf_bypass(self):
        """WAF检测和绕过"""
        console.print("[bold blue]正在检测WAF...[/bold blue]")
        
        waf_bypass = WAFBypass()
        waf_info = waf_bypass.detect_waf(f"http://{self.target}")
        
        if waf_info['detected']:
            console.print(f"[yellow]检测到WAF: {', '.join(waf_info['waf_types'])}[/yellow]")
            
            # 生成并测试绕过payload
            original_payloads = [
                "' OR '1'='1",
                "UNION SELECT NULL--",
                "../../etc/passwd"
            ]
            
            for waf_type in waf_info['waf_types']:
                for payload in original_payloads:
                    bypass_payloads = waf_bypass.generate_bypass_payloads(payload, waf_type)
                    waf_bypass.test_bypass(f"http://{self.target}", bypass_payloads)
            
            # 保存有效的绕过payload
            self.results['waf_bypass'] = {
                'waf_info': waf_info,
                'effective_payloads': waf_bypass.get_effective_payloads()
            }
            
            # 导出结果
            waf_bypass.export_results(os.path.join(self.output_dir, 'waf_bypass.json'))
        else:
            console.print("[green]未检测到WAF[/green]")
    
    def _info_gathering(self):
        """信息收集阶段"""
        console.print("[bold blue]正在进行信息收集...[/bold blue]")
        info_gatherer = InfoGathering(self.target)
        self.results['info_gathering'] = info_gatherer.gather_all()
    
    def _port_scan(self):
        """端口扫描阶段"""
        console.print("[bold blue]正在进行端口扫描...[/bold blue]")
        scanner = PortScanner(self.target, self.level)
        self.results['port_scan'] = scanner.scan()
        
        # 导出扫描结果
        scanner.export_json(os.path.join(self.output_dir, 'port_scan.json'))
    
    def _vulnerability_scan(self):
        """漏洞扫描阶段"""
        console.print("[bold blue]正在进行漏洞扫描...[/bold blue]")
        
        # 获取开放端口
        ports = []
        if 'port_scan' in self.results:
            for host in self.results['port_scan']:
                for proto in self.results['port_scan'][host]['protocols']:
                    ports.extend(int(port) for port in self.results['port_scan'][host]['protocols'][proto].keys())
        
        vuln_scanner = VulnScanner(self.target, ports)
        self.results['vuln_scan'] = vuln_scanner.scan_all()
        
        # 导出扫描结果
        vuln_scanner.export_json(os.path.join(self.output_dir, 'vuln_scan.json'))
    
    def _exploit(self):
        """漏洞利用阶段"""
        console.print("[bold blue]正在尝试漏洞利用...[/bold blue]")
        
        exploit_manager = ExploitManager(self.target)
        
        # 根据漏洞扫描结果搜索可用exploit
        if 'vuln_scan' in self.results:
            for service_type, results in self.results['vuln_scan'].items():
                if isinstance(results, dict):
                    for tool, findings in results.items():
                        if findings.get('vulnerable', False):
                            # 搜索相关exploit
                            exploits = exploit_manager.search_exploit(service_type)
                            
                            # 尝试运行exploit
                            for exploit in exploits:
                                exploit_manager.run_exploit(exploit['name'])
        
        self.results['exploit'] = exploit_manager.results
        exploit_manager.export_results(os.path.join(self.output_dir, 'exploit_results.json'))
    
    def _post_exploit(self):
        """后渗透阶段"""
        console.print("[bold blue]正在进行后渗透操作...[/bold blue]")
        
        post_exploit = PostExploit(self.target)
        
        # 获取凭据
        post_exploit.dump_credentials(os.path.join(self.output_dir, 'loot'))
        
        # 枚举域环境
        post_exploit.enum_domain(os.path.join(self.output_dir, 'bloodhound'))
        
        # 获取密码哈希
        post_exploit.hashdump()
        
        self.results['post_exploit'] = post_exploit.results
        post_exploit.export_results(os.path.join(self.output_dir, 'post_exploit.json'))
    
    def _ai_analysis(self):
        """AI分析阶段"""
        console.print("[bold blue]正在进行AI分析...[/bold blue]")
        
        analyzer = AIAnalyzer()
        
        # 预测漏洞
        vulnerabilities = analyzer.predict_vulnerabilities(self.results)
        
        # 生成修复建议
        recommendations = analyzer.generate_recommendations(vulnerabilities)
        
        # 导出分析结果
        analyzer.export_to_csv(os.path.join(self.output_dir, 'ai_analysis.csv'))
        analyzer.export_results(os.path.join(self.output_dir, 'ai_analysis.json'))
        
        self.results['ai_analysis'] = {
            'vulnerabilities': vulnerabilities,
            'recommendations': recommendations
        }
    
    def _generate_report(self):
        """生成报告"""
        console.print("[bold blue]正在生成报告...[/bold blue]")
        
        report_generator = ReportGenerator(self.target, self.results)
        
        # 生成HTML报告
        report_generator.generate_html(os.path.join(self.output_dir, 'report.html'))
        
        # 生成PDF报告
        report_generator.generate_pdf(os.path.join(self.output_dir, 'report.pdf'))
        
        console.print(f"[green]报告已生成在目录: {self.output_dir}[/green]")

def main():
    parser = argparse.ArgumentParser(description="AutoPentest - 自动化渗透测试工具")
    parser.add_argument("-u", "--url", required=True, help="目标URL或IP地址")
    parser.add_argument("--level", type=int, default=1, choices=[1,2,3,4,5], help="扫描级别(1-5)")
    parser.add_argument("--output", help="报告输出路径")
    parser.add_argument("--quiet", action="store_true", help="静默模式")
    parser.add_argument("--docker", action="store_true", help="在Docker中运行")
    parser.add_argument("--bypass-waf", action="store_true", help="启用WAF绕过模式")
    
    args = parser.parse_args()
    
    try:
        pentest = AutoPentest(
            target=args.url,
            level=args.level,
            output=args.output,
            quiet=args.quiet,
            bypass_waf=args.bypass_waf
        )
        pentest.start()
    except KeyboardInterrupt:
        console.print("\n[bold red]用户中断测试[/bold red]")
        sys.exit(1)
    except Exception as e:
        console.print(f"[bold red]错误: {str(e)}[/bold red]")
        sys.exit(1)

if __name__ == "__main__":
    main() 